= ðŸŒŽ Elm I18n 

This package is a library and an executable to generate optimized JSON files and Elm Modules to decode these JSON files from 
different common I18n formats. 

== ðŸ” Feature Overview 

[none]
* âœ”ï¸ Supports .json and .properties files as input
* ðŸ•µï¸â€â™‚ï¸ Errors out if i18n keys are inconsistent across languages
* ðŸš€ Key lengths does not impact resource size 
* âœ¨ Decodes values with placeholders into Elm functions
* ðŸ”‘ Generated Elm module exposes functions based on keys
* ðŸŽŒ Simple runtime switching of languages
* ðŸ–‹ï¸ Node API is written in Typescript


== ðŸ“– How to use

. Install this package from npm with `npm install --save-dev elm-i18n`.

. Put your translations in files of one of the supported formatsand bundle them in a folder. The filenames should follow the pattern `[identifier].[language].[extension]`.
. Choose a filepath for the generated Elm file.
. Choose a folder for the JSON output
. Run the script with one of the methods described below
. Follow the output documentation to actually run the code

=== âŒ¨ï¸ Script usage

Run 
-----
npx elm-i18n --elm_path=src/I18n.elm --json_path=dist/i18n [folder with translation files]
-----

Alternatively, add a script to your `package.json` with the content
-----
elm-i18n --elm_path=src/I18n.elm --json_path=dist/i18n [folder with translation files]
-----

and then run that script with `npm run [scriptname]`.

=== ðŸ“¦ Usage as a node module

If you need more customizable behaviour, or need to embed this inside a more complex script or plugin, you can import this module 
in a js or ts file and go from there.

Let the types guide you ðŸ¦®.

== Embedding the output in your application

To use the output generated by this package in your application, the general idea is to store the active translations inside your `Model` and load translations on `init` and on demand. To do that, you send an HTTP request to get the generated JSON file from your server and use the generated `decoder` to parse the response.

In your view, you can access your translations by the exposed accessor functions of the generated Elm module.

TL;DR (show me the code!):

[source=elm]
----
module Main exposing (main)

import I18n
import Http

type alias Model =
  { i18n : I18n
  }

init : String -> (Model, Cmd Msg)
init language = ( { i18n = I18n.init },  )  
----


